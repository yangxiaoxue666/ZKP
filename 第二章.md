# 第二章

编码一个函数（非空数集上的映射）$out=f(x_1,x_2,…，x_j)$, $\vec{x}=\{x_1,…,x_h\}$为输入变量，$out$为函数输出。

**convert execution of the circuit into computation trace**

# 2.1 Turning Computer Programs Into Circuits

## RAM: RandomAccessMachine



## The Transformation From Computer Programs To Arithmetic Circuit Satisfiability



# 2.2 Arithmetization

- 仅支持顺序结构程序，不支持循环和分支
- 支持加法，减法，乘法，除法其中，加法和乘法直接转化成加法门和乘法门，减法转化成加逆元，除法转化成乘逆元
- 除法的转换？

## 2.2.1 R1CS

- **Flattening：**即将复合函数以乘法为基本单元拆解成一组有序的简单函数$\{constraint_1,…,constraint_n\}$，其中
    - $constraint_i:=w_i=(u_{i1}+…+u_{it})*(v_{i1}+…+v_{iv})$, $w_i$为输出变量，$\{u_1,…,u_n\}$为左输入变量，$\{ v_1,…,v_m\}$为右输入变量
    - 这里的有序是指计算的顺序
    - 这里会引入中间变量$\{sym\_1,…,sym\_k\}$。
- **重组$\{constraints\}$中的数据**：将其变成一阶约束系统R1CS：$W·\vec{a}=U·\vec{a}\circ V·\vec{a}$(注：$\circ$ 为Hadamard product，按位乘法):
    - $\vec{a}:=\{one\}+\{out\}+\{x_1,…,x_h\}+\{sym\_1,…,sym\_k\}$，即由表示1的冗余变量，函数输出，输入变量，中间变量构成的集合对应的向量。
    - $W:=$$\{constraint_1,…,constraint_n\}$的输出变量基于$\vec{a}$的选择向量构成的矩阵
    - $U:=$$\{constraint_1,…,constraint_n\}$的左输入变量基于$\vec{a}$的选择向量构成的矩阵
    - $V:=$$\{constraint_1,…,constraint_n\}$的右输入变量基于$\vec{a}$的选择向量构成的矩阵
- **注**：矩阵的行数等于乘法门的数量，矩阵的列数等于$\vec{a}$中元素的数量，即变量的数量

## 2.2.2 Plonkish Arithmetization

- **Flattening：**即将复合函数拆解成一组离散的门$\{constraint_1,…,constraint_n\}$，其中
    - $constraint_i:=q_{Oi}w_i=q_{Li}u_i+q_{Ri}v_i+q_{Mi} u_iv_i+q_{Ci}c_i$， $w_i$为输出变量，$u_i$为左输入变量，$v_i$为右输入变量，$c_i$为常量，$q_{Oi}$为输出选择器，$q_{Li}$为左输入变量选择器，$q_{Ri}$为右输入变量选择器，$q_{Mi}$为乘积选择器，$q_{Ci}$为常数选择器
    - **注：**矩阵的行数等于所有门的数量，即约束的数量，n。
    - 这里的有序是指计算的顺序
    - 这里会引入中间变量$\{sym\_1,…,sym\_k\}$。
- **重组$\{constraint_1,…,constraint_n\}$中的数据：**将其变成：$\vec{q_O}\circ \vec{w}=\vec{q_L}\circ\vec{u}+\vec{q_R}\circ\vec{v}+\vec{q_M}\circ(\vec{u}\circ\vec{v})+\vec{q_C}\circ\vec{c}$(注：$\circ$ 为Hadamard product，按位乘法)
    - $Q:=\{\vec{q_O},\vec{q_L},\vec{q_R},\vec{q_M},\vec{q_C}\}$，即选择器矩阵
    - $W:=\{\vec{w},\vec{u},\vec{v}\}$，即变量矩阵
    - $S^\delta:=$ 轮换置换后得到的位置集合，来自于**Wiring**
- **Wiring:** 将离散的门连接起来，即某一个门的输出引脚要接入另一个门的输入引脚
    - 理解：某一个门的输出引脚要接入另一个门的输入引脚 ↔ 约束变量矩阵$W$中某几个位置的元素是相等的 ↔ 这一个元素出现在$W$矩阵的多个位置处
    - Wiring实现思路：
        - 把$W$矩阵中的每一个位置从1到3n进行唯一编号，则所有的编号构成一个位置集合$S$，将位置集合$S$对应的元素取出构成一个multiset $S_e$
        - 把每个元素出现在$W$中的位置编号取出放在一个集合中$s$，即一个元素对应一个位置集合$s$。将位置集合对应的元素取出构成一个multiset $s_e$。所有元素的$s$的并集即为$S$，$s_e$的并集为 $S_e$
        - $\forall s$，要使得 $s_e$中元素全部相等  ↔  $\forall s$， $s_e$与其进行轮换置换$\delta$后得到的集合$s_{e}^{\delta}$在Multiset的意义上是等价的 ↔   $\forall s$， $\vec{ s}+\vec{ s_{e}}$与$\vec{ s^{\delta}}+\vec{s_{e}^{\delta}}$在Multiset的意义上是等价的 ←  令$S^\delta$为所有$s^{\delta}$的并集，$S^\delta_e$为所有$s_{e}^{\delta}$的并集， $\vec{ S}+\vec{ S_{e}}$与$\vec{ S^{\delta}}+\vec{S_{e}^{\delta}}$在Multiset的意义上是等价的
- **注：**矩阵的行数等于所有门的数量，矩阵的列数恒等于5

# 2.3 Merge Constraints



# 2.4 PCS





### 参考文献

[零知识证明（13）：R1CS与QAP - 三两老友杂的小岛](https://snowolf0620.xyz/index.php/zkp/435.html)